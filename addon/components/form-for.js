import Ember from 'ember';
import Changeset from 'ember-changeset';
import lookupValidator from 'ember-changeset-validations';

const Promise = Ember.RSVP.Promise;
const computed = Ember.computed;
const { not } = Ember.computed;

const FormFor = Ember.Component.extend({


  // Options
  //

  /**
   * The DS.Model, Ember.Object, or even POJO, that provides the data for this
   * form.
   *
   * @type {Object}
   */
  object: null,

  /**
   * The validations object that can be passed to ember-changeset-validations
   * lookupValidator method and applied against the object.
   *
   * @type {Object}
   */
  validations: null,

  /**
   * When should validation errors be shown? Accepts:
   *
   *  * 'live' - as you type
   *  * 'touch' - once a field has received any interaction and the user has
   *  moved on (i.e. 'focusout')
   *  * 'submit' - once the form is actually submitted
   *  * false - don't validate
   *
   * Note that 'live' and 'touch' imply 'submit' as well - that is, once a form
   * is submitted, all fields will be validated unless validation is turned off
   * for the entire form.
   *
   * @type {String}
   * @default 'touch'
   */
  validateOn: 'touch',

  /**
   * Should form controls display autogenerated placeholders based on the field
   * name?
   *
   * @type {Boolean}
   * @default true
   */
  placeholders: true,

  /**
   * If false, requires that the form be changed before the submit action will
   * fire.
   * @type {Boolean}
   * @default false
   */
  allowPristineSaves: false,

  /**
   * The method invoked when the form is successfully submitted (i.e. submitted
   * and passes validation).
   *
   * Default behavior is to invoke `save()` on the changeset.
   *
   * @method action
   * @param changeset {Changeset}
   * @returns {Promise}
   */
  action(changeset) {
    return changeset.save();
  },


  // Internal state
  //

  tagName: 'form',

  /**
   * The source changeset for this form.
   *
   * @type {Changeset}
   */
  changeset: computed('object', 'validations', function() {
    return new Changeset(this.get('object'), lookupValidator(this.get('validations')), this.get('validations'));
  }),

  /**
   * Is this form currently in-flight?
   *
   * @type {Boolean}
   */
  isSubmitting: false,

  /**
   * Was this form ever submitted, even once?
   *
   * @type {Boolean}
   */
  wasSubmitted: false,

  /**
   * Can the form currently be submitted? Useful for disabling submit buttons
   * and otherwise limiting the UI to prevent double submits.
   *
   * @type {Boolean}
   */
  canAttemptSubmit: computed('isSubmitting', 'allowPristineSaves', 'changeset.isDirty', function() {
    return (this.get('changeset.isDirty') || this.get('allowPristineSaves')) && !this.get('isSubmitting');
  }),

  /**
   * Save the form on the submit event.
   *
   * @method submit
   */
  submit(e) {
    if (e) {
      e.preventDefault();
    }
    if (this.get('canAttemptSubmit')) {
      this.set('isSubmitting', true);
      return this._validate().then(() => {
        return Promise.resolve(this.action(this.get('changeset'))).catch(this.handleSubmitErrors.bind(this));
      }).finally(() => {
        if (!this.get('isDestroying')) {
          this.set('isSubmitting', false);
          this.set('wasSubmitted', true);
        }
      });
    }
  },

  /**
   * Run validations on the changeset, if enabled, and return a promise that
   * rejects if any fail.
   *
   * @method _validate
   * @private
   */
  _validate() {
    return new Promise((resolve, reject) => {
      if (this.get('validateOn') !== false) {
        return this.get('changeset').validate().then(() => {
          return this.get('changeset.isValid') ? resolve() : reject();
        });
      }
    });
  },

  /**
   * Invoked when the form action rejects. You can add any generic or global
   * error handling you want here. By default, it checks for an `.errors`
   * property on the object that follows the Ember Data errors interface, and
   * adds those errors. It also checks if the form's action rejected with an
   * AdapterError (i.e. a server 500). If so, it adds the adapter error to the
   * form-wide error.
   *
   * @method handleSubmitErrors
   * @param error The value that the form's action rejected with
   */
  handleSubmitErrors(error) {
    if (error.isAdapterError) {
      let adapterError = error.errors.find((error) => error.title === 'Adapter Error');
      if (adapterError) {
        this.set('formError', adapterError.detail);
      }
    }
    let errors = this.get('object.errors');
    if (errors) {
      errors.forEach(({ attribute, message }) => {
        this.get('changeset').pushErrors(attribute, message);
      });
    }
  },

  /**
   * The list of fields that are "active" for validation - i.e. should show
   * validation errors if any occur.
   *
   * @type {Array}
   */
  activeFields: computed(function() {
    return Ember.A();
  }),

  /**
   * Called by the various input components when their value changes (i.e. on
   * key-up for an input).
   *
   * @method fieldChanged
   * @param field {String} the name of the field that changed
   * @param validateOn {String} the validation strategy to use; defaults to the
   * form's strategy, but gives each input a chance to override if the user
   * wants to
   */
  fieldChanged(field, validateOn = this.get('validateOn')) {
    if (validateOn === 'live') {
      this.get('activeFields').addObject(field);
      this.get('changeset').validate(field);
    }
  },

  /**
   * Called by the various input components when user finishes making edits
   * (i.e. on focus-out for an input).
   *
   * @method fieldTouched
   * @param field {String} the name of the field that changed
   * @param validateOn {String} the validation strategy to use; defaults to the
   * form's strategy, but gives each input a chance to override if the user
   * wants to
   */
  fieldTouched(field, validateOn = this.get('validateOn')) {
    if (validateOn === 'touch') {
      this.get('activeFields').addObject(field);
      this.get('changeset').validate(field);
    }
  },

  actions: {
    submit() {
      this.submit();
    }
  }

});

FormFor.reopenClass({
  positionalParams: [ 'object', 'validations' ]
});

export default FormFor;
